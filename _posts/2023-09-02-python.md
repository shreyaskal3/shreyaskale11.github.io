---
title: Basic SQL
date: 2023-09-04 00:00:00 +0800
categories: [python, Basic_SQL]
tags: [python]
---



### Item 11: Know How to Slice Sequences

```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

# Basic slicing
print('Middle two:', a[3:5])
print('All but ends:', a[1:7])

# Negative indexing
print(a[:5] == a[0:5])
print(a[5:] == a[5:len(a)])

# Various slicing examples
print(a[:])      # Entire list
print(a[:5])     # First five elements
print(a[:-1])    # All but the last element
print(a[4:])     # Elements from index 4 to the end
print(a[-3:])    # Last three elements
print(a[2:5])    # Elements from index 2 to 4
print(a[2:-1])   # Elements from index 2 to the second-to-last
print(a[-3:-1])  # Elements from the third-to-last to the second-to-last
```

### Item 12: Avoid Striding and Slicing in a Single Expression

```python
# Striding examples
x = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
odds = x[::2]
evens = x[1::2]

# Striding with negative values
x[::-2]  # Reverse every second item
x[2::2]  # Select every second item starting at index 2

# Avoid striding and slicing in a single expression
y = x[::2]  # Good
z = y[1:-1]  # Good
```

### Item 13: Prefer Catch-All Unpacking Over Slicing

```python
# Basic unpacking
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
oldest, second_oldest = car_ages[:2]

# Catch-all unpacking
oldest, second_oldest, *others = car_ages_descending

# Using catch-all unpacking for slices
oldest, *others, youngest = car_ages_descending
*others, second_youngest, youngest = car_ages_descending
```

### Item 14: Sort by Complex Criteria Using the key Parameter

```python
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

tools = [
    Tool('level', 3.5),
    Tool('hammer', 1.25),
    Tool('screwdriver', 0.5),
    Tool('chisel', 0.25),
]

# Sorting by name
tools.sort(key=lambda x: x.name)

# Sorting by weight
tools.sort(key=lambda x: x.weight)

# Sorting by weight descending, then by name ascending
tools.sort(key=lambda x: (x.weight, x.name))

# Sorting by weight descending, then by name ascending (alternative)
tools.sort(key=lambda x: -x.weight)
tools.sort(key=lambda x: x.name)

```

### Item 15: Be Cautious When Relying on dict Insertion Ordering

- In Python 3.5 and earlier, iterating over a dict did not guarantee order.
- Starting with Python 3.6, dictionaries preserve insertion order.
- Be cautious when relying on insertion order for dict-related operations.

```python
# Python 3.5
baby_names = {'cat': 'kitten', 'dog': 'puppy'}
print(list(baby_names.keys()))  # May not preserve insertion order

# Python 3.6+
baby_names = {'cat': 'kitten', 'dog': 'puppy'}
print(list(baby_names.keys()))  # Preserves insertion order
```

### Item 16: Prefer `get` Over `in` and `KeyError` to Handle Missing Dictionary Keys

- Use `get` method for cleaner code when handling missing keys.
- It's efficient and readable compared to `in` checks or catching `KeyError`.

```python
votes = {'otter': 1281, 'polar bear': 587, 'fox': 863}
key = 'wombat'

# Using get
count = votes.get(key, 0)
votes[key] = count + 1
```

### Item 17: Prefer `defaultdict` Over `setdefault` to Handle Missing Items in Internal State

- `defaultdict` from `collections` module simplifies handling missing keys.
- It's more efficient and avoids unnecessary object creation compared to `setdefault`.

```python
from collections import defaultdict

class Visits:
    def __init__(self):
        self.data = defaultdict(set)

    def add(self, country, city):
        self.data[country].add(city)

# Usage
visits = Visits()
visits.add('France', 'Paris')
print(visits.data)
```

### Item 18: Know How to Construct Key-Dependent Default Values with `__missing__`

- Subclass `dict` and implement `__missing__` method to customize default value creation based on keys.

```python
def open_picture(profile_path):
    try:
        return open(profile_path, 'a+b')
    except OSError:
        print(f'Failed to open path {profile_path}')
        raise

class Pictures(dict):
    def __missing__(self, key):
        value = open_picture(key)
        self[key] = value
        return value

# Usage
pictures = Pictures()
handle = pictures['profile_1234.png']
handle.seek(0)
image_data = handle.read()
```


## Item 22: Reduce Visual Noise with Variable Positional Arguments

Accepting a variable number of positional arguments can make a function call clearer and reduce visual noise. These positional arguments are often called varargs or star args.

### Example 1: Basic Usage of *args

```python
def log(message, *values):
    if not values:
        print(message)
    else:
        values_str = ', '.join(str(x) for x in values)
        print(f'{message}: {values_str}')

# Call the function with multiple values
log('My numbers are', 1, 2)
log('Hi there')  # No values passed
```

In this example, the `*values` syntax allows the function to accept a variable number of positional arguments. The function prints the message and, if values are provided, it prints them as well.

### Example 2: Using *args with a Sequence

```python
favorites = [7, 33, 99]
log('Favorite colors', *favorites)
```

The `*` operator can be used to pass items from a sequence as positional arguments to a function. This is useful when you have a list of values to pass.

### Pitfalls:

1. **Generator Exhaustion:**
   ```python
   def my_generator():
       for i in range(10):
           yield i

   def my_func(*args):
       print(args)

   it = my_generator()
   my_func(*it)  # This may consume a lot of memory
   ```

   Be cautious when using *args with generators, as it can lead to generator exhaustion.

2. **Adding New Positional Arguments:**
   ```python
   def log(sequence, message, *values):
       if not values:
           print(f'{sequence} - {message}')
       else:
           values_str = ', '.join(str(x) for x in values)
           print(f'{sequence} - {message}: {values_str}')

   log(1, 'Favorites', 7, 33)        # New with *args OK
   log(1, 'Hi there')                 # New message only OK
   log('Favorite numbers', 7, 33)    # Old usage breaks
   ```

   Adding new positional parameters to functions that accept *args can introduce hard-to-detect bugs. Consider using keyword-only arguments for extension.

**Things to Remember:**
- Functions can accept a variable number of positional arguments by using *args in the def statement.
- The * operator can be used to pass items from a sequence as positional arguments.
- Be cautious with generators, as using *args with them may cause memory issues.
- Adding new positional parameters to functions accepting *args can introduce bugs; consider using keyword-only arguments.


## Item 23: Provide Optional Behavior with Keyword Arguments

Keyword arguments allow you to provide optional parameters to a function, making it more flexible and self-documenting. This can improve the clarity of function calls and make your code more maintainable.

### Example:

```python
def create_person(name, age, job=None, city=None):
    person_info = f"{name}, {age} years old"
    if job:
        person_info += f", works as a {job}"
    if city:
        person_info += f", lives in {city}"
    return person_info

# Call the function with different sets of arguments
person1 = create_person("Alice", 30, job="Engineer", city="New York")
person2 = create_person("Bob", 25, city="San Francisco")

print(person1)
print(person2)
```

In this example, the `create_person` function takes mandatory parameters (`name` and `age`) and two optional parameters (`job` and `city`). By using keyword arguments, you can choose which optional parameters to include when calling the function.

### Benefits of Keyword Arguments:

1. **Clarity and Readability:**
   Keyword arguments make it clear which values correspond to which parameters, improving code readability.

2. **Default Values:**
   Setting default values for keyword arguments allows you to define optional parameters without requiring them in every function call.

3. **Flexibility:**
   Users can choose to provide only the necessary information, ignoring the optional parameters they don't need.

### Pitfall:

- **Mutable Default Values:**
  ```python
  def add_item(item, items=[]):
      items.append(item)
      return items

  result1 = add_item("apple")
  result2 = add_item("banana")

  print(result1)  # Output: ['apple', 'banana']
  ```

  Be cautious when using mutable objects (like lists) as default values for keyword arguments, as they are shared among all calls to the function.

**Things to Remember:**
- Use keyword arguments to provide optional parameters and improve the clarity of function calls.
- Default values for keyword arguments make parameters optional, and users can choose to override them.
- Be cautious with mutable default values to avoid unexpected behavior.

## Item 24: Use `None` and Docstrings to Specify Dynamic Default Arguments

When defining a function with default argument values, using mutable objects (like lists or dictionaries) can lead to unexpected behavior due to shared state between calls. Instead, use `None` as the default and document the behavior clearly using docstrings.

### Example:

```python
def add_item(item, items=None):
    """
    Add an item to the list.

    Parameters:
    - item: The item to add.
    - items: The list to which the item will be added. If None, a new list will be created.

    Returns:
    The updated list.
    """
    if items is None:
        items = []
    items.append(item)
    return items

# Test the function
result1 = add_item("apple")
result2 = add_item("banana")

print(result1)  # Output: ['apple']
print(result2)  # Output: ['banana']
```

In this example, the `add_item` function uses `None` as the default value for the `items` parameter and explicitly checks if it's `None` before creating a new list. This avoids the issue of shared state caused by mutable default values.

### Benefits:

1. **Predictable Behavior:**
   Using `None` as the default value ensures that each call to the function starts with a new, independent object.

2. **Clear Documentation:**
   Including a docstring helps users understand the expected behavior of the function, especially regarding default arguments.

### Pitfall:

- **Mutable Default Values:**
  ```python
  def add_item(item, items=[]):
      """
      Add an item to the list.

      Parameters:
      - item: The item to add.
      - items: The list to which the item will be added. If None, a new list will be created.

      Returns:
      The updated list.
      """
      items.append(item)
      return items

  result1 = add_item("apple")
  result2 = add_item("banana")

  print(result1)  # Output: ['apple', 'banana']
  ```

  If you use a mutable object as a default value without handling it properly, you might encounter unexpected behavior due to shared state.

**Things to Remember:**
- Use `None` as the default value for mutable arguments to avoid shared state.
- Explicitly check for `None` and create a new instance within the function.
- Document the function's behavior, especially regarding default arguments, using docstrings.

